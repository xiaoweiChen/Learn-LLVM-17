The ELF file format is one of the binary object file formats LLVM supports. ELF itself is defined for many CPU architectures, and there is also a definition for the M88k architecture. All we need to do is to add the definition of the relocations and some flags. The relocations are given in Chapter 4, Basics of IR Code Generation, of the System V ABI M88k Processor supplement book (see link within the Setting the stage for a new backend section at the beginning of the chapter):

\begin{enumerate}
\item
We need to type the following code into the llvm/include/llvm/BinaryFormat/ ELFRelocs/M88k.def file:

\begin{cpp}
#ifndef ELF_RELOC
#error "ELF_RELOC must be defined"
#endif
ELF_RELOC(R_88K_NONE, 0)
ELF_RELOC(R_88K_COPY, 1)
// Many moreâ€¦
\end{cpp}

\item
We also add the following flags into the llvm/include/llvm/BinaryFormat/ELF.h file, along with the definition of the relocations:

\begin{cpp}
// M88k Specific e_flags
enum : unsigned {
    EF_88K_NABI = 0x80000000, // Not ABI compliant
    EF_88K_M88110 = 0x00000004 // File uses 88110-specific
    features
};

// M88k relocations.
enum {
    #include "ELFRelocs/M88k.def"
};
\end{cpp}

The code can be added anywhere in the file, but it is best to keep the file structured and insert it before the code for the MIPS architecture.

\item
We also need to expand some other methods. In the llvm/include/llvm/Object/ ELFObjectFile.h file are some methods that translate between enumeration members and strings. For example, we must add a new case statement to the getFileFormatName() method:

\begin{cpp}
switch (EF.getHeader()->e_ident[ELF::EI_CLASS]) {
    // Many more cases
    case ELF::EM_88K:
    return "elf32-m88k";
}
\end{cpp}

\item
Similarly, we extend the getArch() method:

\begin{cpp}
switch (EF.getHeader().e_machine) {
    // Many more cases
    case ELF::EM_88K:
    return Triple::m88k;
\end{cpp}

\item
Lastly, we use the relocation definitions in the llvm/lib/Object/ELF.cpp file, in the getELFRelocationTypeName() method:

\begin{cpp}
switch (Machine) {
    // Many more cases
    case ELF::EM_88K:
    switch (Type) {
        #include "llvm/BinaryFormat/ELFRelocs/M88k.def"
        default:
        break;
    }
    break;
}
\end{cpp}

\item
To complete the support, you can valso extend the llvm/lib/ObjectYAML/ELFYAML. cpp file. This file is used by the yaml2obj and obj2yaml tools, which create an ELF file based on a YAML description, and vice versa. The first addition needs to be done in the ScalarEnumerationTraits<ELFYAML::ELF\_EM>::enumeration() method, which lists all the values for the ELF architectures:

\begin{cpp}
ECase(EM_88K);
\end{cpp}

\item
Likewise, in the ScalarEnumerationTraits<ELFYAML::ELF\_REL>::enumeration() method, you need to include the definitions of the relocations again:

\begin{cpp}
    case ELF::EM_88K:
#include "llvm/BinaryFormat/ELFRelocs/M88k.def"
    break;
\end{cpp}
\end{enumerate}

At this point, we have completed the support of the m88k architecture in the ELF file format. You can use the llvm-readobj tool to inspect an ELF object file, for example, created by a crosscompiler on OpenBSD. Likewise, you can create an ELF object file for the m88k architecture with the yaml2obj tool.

\begin{myNotic}{Is adding support for an object file format mandatory?}
Integrating support for an architecture into the ELF file format implementation requires only a couple of lines of code. If the architecture for which you are creating an LLVM backend uses the ELF format, then you should take this route. On the other hand, adding support for a completely new binary file format is a complicated task. If this is required, then an often-used approach is to only output assembler files and use an external assembler to create object files.
\end{myNotic}

With these additions, the LLVM implementation of the ELF file format now supports the M88k architecture. In the next section, we create the target description for the M88k architecture, which describes the instructions, the registers, and many more details of the architecture.

















